package bincludegen

import (
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"sort"
	"strconv"

	"github.com/lu4p/binclude"
)

func dataToByteSlice(data []byte) *ast.CallExpr {
	return callExpr(&ast.ArrayType{Elt: ident("byte")},
		stringLiteral(string(data)),
	)
}

func fileToAst(path string, file *binclude.File, num int, buildTag string) (c *ast.ValueSpec, m *ast.KeyValueExpr) {
	constName := "_binclude" + buildTag + strconv.Itoa(num)
	var x ast.Expr = ident("nil")

	if !file.Mode.IsDir() {
		c = &ast.ValueSpec{
			Names: []*ast.Ident{ident(constName)},
			Values: []ast.Expr{
				dataToByteSlice(file.Content),
			},
		}

		x = ident(constName)
	}

	compressionName := "None"
	if file.Compression == binclude.Gzip {
		compressionName = "Gzip"
	}

	m = &ast.KeyValueExpr{
		Key: stringLiteral(path),
		Value: &ast.CompositeLit{
			Elts: []ast.Expr{
				&ast.KeyValueExpr{
					Key:   ident("Filename"),
					Value: stringLiteral(file.Filename),
				},
				&ast.KeyValueExpr{
					Key:   ident("Mode"),
					Value: intLiteral(int(file.Mode)),
				},
				&ast.KeyValueExpr{
					Key: ident("ModTime"),
					Value: callExpr(selExpr("time", "Unix"),
						intLiteral(int(file.ModTime.Unix())),
						intLiteral(file.ModTime.Nanosecond()),
					),
				},
				&ast.KeyValueExpr{
					Key:   ident("Compression"),
					Value: selExpr("binclude", compressionName),
				},
				&ast.KeyValueExpr{
					Key:   ident("Content"),
					Value: x,
				},
			},
		},
	}

	return c, m
}

func fileSystem2Ast(pkgName string, fs *binclude.FileSystem, buildTag string) *ast.File {
	var (
		astConsts []ast.Spec
		astFiles  []ast.Expr
	)

	num := 0

	var paths []string
	for path := range fs.Files {
		paths = append(paths, path)
	}

	sort.Strings(paths)

	for _, path := range paths {
		file := fs.Files[path]
		astConst, astFile := fileToAst(path, file, num, buildTag)
		if !file.Mode.IsDir() {
			astConsts = append(astConsts, astConst)
			num++
		}

		astFiles = append(astFiles, astFile)
	}

	fsName := "BinFS"
	if buildTag != "" {
		fsName = "_binfs" + buildTag
	}

	astVars := append(astConsts, &ast.ValueSpec{
		Names: []*ast.Ident{ident(fsName)},
		Values: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: selExpr("binclude", "FileSystem"),
					Elts: []ast.Expr{
						&ast.KeyValueExpr{
							Key: ident("Files"),
							Value: &ast.CompositeLit{
								Type: &ast.MapType{
									Key: ident("string"),
									Value: &ast.StarExpr{
										X: selExpr("binclude", "File"),
									},
								},
								Elts: astFiles,
							},
						},
					},
				},
			},
		},
	})

	imports := []ast.Spec{importSpec("github.com/lu4p/binclude")}

	if len(astFiles) > 0 {
		imports = append(imports, importSpec("time"))
	}

	return &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: 1,
					Text:  "// Code generated by binclude; DO NOT EDIT.",
				},
			},
		},
		Package: 45,
		Name:    ident(pkgName),
		Decls: []ast.Decl{
			genDecl(token.IMPORT, imports),
			genDecl(token.VAR, astVars),
		},
	}
}

func generateFiles(pkgName string, fileSystems map[string]*binclude.FileSystem) error {
	for buildTag, fs := range fileSystems {
		if buildTag == "default" {
			err := generateFile(pkgName, fs)
			if err != nil {
				return err
			}
			continue
		}

		err := generateTagFile(pkgName, fs, buildTag)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateFile(pkgName string, fs *binclude.FileSystem) error {
	bincludeFile := fileSystem2Ast(pkgName, fs, "")

	return writeAstToFile(bincludeFile, "binclude.go")
}

func generateTagFile(pkgName string, fs *binclude.FileSystem, buildTag string) error {
	bincludeFile := fileSystem2Ast(pkgName, fs, buildTag)

	decl := &ast.FuncDecl{
		Name: ident("init"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
		},
		Body: blockStmt(
			exprStmt(callExpr(selExpr("BinFS", "Lock"))),
			&ast.RangeStmt{
				Key:   ident("path"),
				Value: ident("file"),
				Tok:   token.DEFINE,
				X:     selExpr("_binfs"+buildTag, "Files"),
				Body: blockStmt(&ast.AssignStmt{
					Lhs: []ast.Expr{
						indexExpr(selExpr("BinFS", "Files"), ident("path")),
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{ident("file")},
				}),
			},
			exprStmt(callExpr(selExpr("BinFS", "Unlock"))),
		),
	}
	bincludeFile.Decls = append(bincludeFile.Decls, decl)

	return writeAstToFile(bincludeFile, "binclude"+buildTag+".go")
}

func writeAstToFile(file *ast.File, filename string) error {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	return format.Node(f, fset, file)
}
