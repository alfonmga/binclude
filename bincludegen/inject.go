package bincludegen

import (
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"strconv"

	"github.com/lu4p/binclude"
)

func dataToByteSlice(data []byte) *ast.CallExpr {
	return &ast.CallExpr{
		Fun: &ast.ArrayType{
			Elt: &ast.Ident{Name: "byte"},
		},
		Args: []ast.Expr{&ast.BasicLit{
			Kind:  token.STRING,
			Value: fmt.Sprintf("%q", data),
		}},
	}
}

func fileToAst(path string, file *binclude.File, num int) (c *ast.ValueSpec, m *ast.KeyValueExpr) {
	constName := "_binclude" + strconv.Itoa(num)
	var x ast.Expr = &ast.Ident{Name: "nil"}

	if !file.Mode.IsDir() {
		c = &ast.ValueSpec{
			Names: []*ast.Ident{
				{Name: constName},
			},
			Values: []ast.Expr{
				dataToByteSlice(file.Content),
			},
		}

		x = &ast.Ident{Name: constName}
	}

	compressionName := "None"
	if file.Compression == binclude.Gzip {
		compressionName = "Gzip"
	} else if file.Compression == binclude.Brotli {
		compressionName = "Brotli"
	}

	m = &ast.KeyValueExpr{
		Key: &ast.BasicLit{
			Kind:  token.STRING,
			Value: `"` + path + `"`,
		},
		Value: &ast.CompositeLit{
			Elts: []ast.Expr{
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "Filename"},
					Value: &ast.BasicLit{
						Kind:  token.STRING,
						Value: `"` + file.Filename + `"`,
					},
				},
				&ast.KeyValueExpr{
					Key: &ast.Ident{
						Name: "Mode",
					},
					Value: &ast.BasicLit{
						Kind:  token.INT,
						Value: strconv.Itoa(int(file.Mode)),
					},
				},
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "ModTime"},
					Value: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "time"},
							Sel: &ast.Ident{Name: "Unix"},
						},
						Args: []ast.Expr{
							&ast.BasicLit{
								Kind:  token.INT,
								Value: strconv.Itoa(int(file.ModTime.Unix())),
							},
							&ast.BasicLit{
								Kind:  token.INT,
								Value: strconv.Itoa(int(file.ModTime.Nanosecond())),
							},
						},
					},
				},
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "Compression"},
					Value: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "binclude"},
						Sel: &ast.Ident{Name: compressionName},
					},
				},
				&ast.KeyValueExpr{
					Key:   &ast.Ident{Name: "Content"},
					Value: x,
				},
			},
		},
	}

	return c, m
}

func generateFile(pkgName *ast.Ident, fs binclude.FileSystem) error {
	var (
		astConsts []ast.Spec
		astFiles  []ast.Expr
	)

	num := 0
	for path, file := range fs {
		astConst, astFile := fileToAst(path, file, num)
		if !file.Mode.IsDir() {
			astConsts = append(astConsts, astConst)
			num++
		}

		astFiles = append(astFiles, astFile)
	}

	astVars := append(astConsts, &ast.ValueSpec{
		Names: []*ast.Ident{
			{Name: "BinFS"},
		},
		Values: []ast.Expr{
			&ast.CompositeLit{
				Type: &ast.SelectorExpr{
					X:   &ast.Ident{Name: "binclude"},
					Sel: &ast.Ident{Name: "FileSystem"},
				},
				Elts: astFiles,
			},
		},
	})

	imports := []ast.Spec{
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: "\"github.com/lu4p/binclude\"",
			},
		},
	}

	if len(astFiles) > 0 {
		imports = append(imports, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: "\"time\"",
			},
		})
	}

	bincludeFile := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: 1,
					Text:  "// Code generated by binclude; DO NOT EDIT.",
				},
			},
		},
		Package: 45,
		Name:    pkgName,
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok:   token.IMPORT,
				Specs: imports,
			},
			&ast.GenDecl{
				Tok:   token.VAR,
				Specs: astVars,
			},
		},
	}

	f, err := os.OpenFile("binclude.go", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	err = printer.Fprint(f, fset, bincludeFile)
	if err != nil {
		return err
	}

	return nil

}
