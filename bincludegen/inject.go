package bincludegen

import (
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"sort"
	"strconv"

	"github.com/lu4p/binclude"
)

func dataToByteSlice(data []byte) *ast.CallExpr {
	return &ast.CallExpr{
		Fun: &ast.ArrayType{
			Elt: &ast.Ident{Name: "byte"},
		},
		Args: []ast.Expr{&ast.BasicLit{
			Kind:  token.STRING,
			Value: fmt.Sprintf("%q", data),
		}},
	}
}

func fileToAst(path string, file *binclude.File, num int, buildTag string) (c *ast.ValueSpec, m *ast.KeyValueExpr) {
	constName := "_binclude" + buildTag + strconv.Itoa(num)
	var x ast.Expr = &ast.Ident{Name: "nil"}

	if !file.Mode.IsDir() {
		c = &ast.ValueSpec{
			Names: []*ast.Ident{
				{Name: constName},
			},
			Values: []ast.Expr{
				dataToByteSlice(file.Content),
			},
		}

		x = &ast.Ident{Name: constName}
	}

	compressionName := "None"
	if file.Compression == binclude.Gzip {
		compressionName = "Gzip"
	}

	m = &ast.KeyValueExpr{
		Key: &ast.BasicLit{
			Kind:  token.STRING,
			Value: `"` + path + `"`,
		},
		Value: &ast.CompositeLit{
			Elts: []ast.Expr{
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "Filename"},
					Value: &ast.BasicLit{
						Kind:  token.STRING,
						Value: `"` + file.Filename + `"`,
					},
				},
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "Mode"},
					Value: &ast.BasicLit{
						Kind:  token.INT,
						Value: strconv.Itoa(int(file.Mode)),
					},
				},
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "ModTime"},
					Value: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "time"},
							Sel: &ast.Ident{Name: "Unix"},
						},
						Args: []ast.Expr{
							&ast.BasicLit{
								Kind:  token.INT,
								Value: strconv.Itoa(int(file.ModTime.Unix())),
							},
							&ast.BasicLit{
								Kind:  token.INT,
								Value: strconv.Itoa(int(file.ModTime.Nanosecond())),
							},
						},
					},
				},
				&ast.KeyValueExpr{
					Key: &ast.Ident{Name: "Compression"},
					Value: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "binclude"},
						Sel: &ast.Ident{Name: compressionName},
					},
				},
				&ast.KeyValueExpr{
					Key:   &ast.Ident{Name: "Content"},
					Value: x,
				},
			},
		},
	}

	return c, m
}

func fileSystem2Ast(pkgName *ast.Ident, fs *binclude.FileSystem, buildTag string) *ast.File {
	var (
		astConsts []ast.Spec
		astFiles  []ast.Expr
	)

	num := 0

	var paths []string
	for path := range fs.Files {
		paths = append(paths, path)
	}

	sort.Strings(paths)

	for _, path := range paths {
		file := fs.Files[path]
		astConst, astFile := fileToAst(path, file, num, buildTag)
		if !file.Mode.IsDir() {
			astConsts = append(astConsts, astConst)
			num++
		}

		astFiles = append(astFiles, astFile)
	}

	fsName := "BinFS"
	if buildTag != "" {
		fsName = "_binfs" + buildTag
	}

	astVars := append(astConsts, &ast.ValueSpec{
		Names: []*ast.Ident{
			{Name: fsName},
		},
		Values: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "binclude"},
						Sel: &ast.Ident{Name: "FileSystem"},
					},
					Elts: []ast.Expr{
						&ast.KeyValueExpr{
							Key: &ast.Ident{Name: "Files"},
							Value: &ast.CompositeLit{
								Type: &ast.MapType{
									Key: &ast.Ident{Name: "string"},
									Value: &ast.StarExpr{
										X: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "binclude"},
											Sel: &ast.Ident{Name: "File"},
										},
									},
								},
								Elts: astFiles,
							},
						},
					},
				},
			},
		},
	})

	imports := []ast.Spec{
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: "\"github.com/lu4p/binclude\"",
			},
		},
	}

	if len(astFiles) > 0 {
		imports = append(imports, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: "\"time\"",
			},
		})
	}

	return &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: 1,
					Text:  "// Code generated by binclude; DO NOT EDIT.",
				},
			},
		},
		Package: 45,
		Name:    pkgName,
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok:   token.IMPORT,
				Specs: imports,
			},
			&ast.GenDecl{
				Tok:   token.VAR,
				Specs: astVars,
			},
		},
	}
}

func generateFiles(pkgName *ast.Ident, fileSystems map[string]*binclude.FileSystem) error {
	for buildTag, fs := range fileSystems {
		if buildTag == "default" {
			err := generateFile(pkgName, fs)
			if err != nil {
				return err
			}
			continue
		}

		err := generateTagFile(pkgName, fs, buildTag)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateFile(pkgName *ast.Ident, fs *binclude.FileSystem) error {
	bincludeFile := fileSystem2Ast(pkgName, fs, "")

	return writeAstToFile(bincludeFile, "binclude.go")
}

func generateTagFile(pkgName *ast.Ident, fs *binclude.FileSystem, buildTag string) error {
	bincludeFile := fileSystem2Ast(pkgName, fs, buildTag)

	bincludeFile.Decls = append(bincludeFile.Decls, &ast.FuncDecl{
		Name: &ast.Ident{
			Name: "init",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "BinFS"},
							Sel: &ast.Ident{Name: "Lock"},
						},
					},
				},
				&ast.RangeStmt{
					Key:   &ast.Ident{Name: "path"},
					Value: &ast.Ident{Name: "file"},
					Tok:   token.DEFINE,
					X: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "_binfs" + buildTag},
						Sel: &ast.Ident{Name: "Files"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.AssignStmt{
								Lhs: []ast.Expr{
									&ast.IndexExpr{
										X: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "BinFS"},
											Sel: &ast.Ident{Name: "Files"},
										},
										Index: &ast.Ident{Name: "path"},
									},
								},
								Tok: token.ASSIGN,
								Rhs: []ast.Expr{
									&ast.Ident{Name: "file"},
								},
							},
						},
					},
				},
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "BinFS"},
							Sel: &ast.Ident{Name: "Unlock"},
						},
					},
				},
			},
		},
	})

	return writeAstToFile(bincludeFile, "binclude"+buildTag+".go")
}

func writeAstToFile(file *ast.File, filename string) error {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	return printer.Fprint(f, fset, file)
}
