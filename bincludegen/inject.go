package bincludegen

import (
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"

	"github.com/lu4p/binclude"
)

func generateCode(pkgName string, fs *binclude.FileSystem, buildTag string) string {
	var b strings.Builder

	header := `// Code generated by https://github.com/lu4p/binclude; DO NOT EDIT.

package ` + pkgName + "\n"

	b.WriteString(header)

	b.WriteString("import (\n")
	b.WriteString("\"github.com/lu4p/binclude\"\n")
	if len(fs.Files) > 0 {
		b.WriteString("\"time\"\n")
	}
	b.WriteString(")\n")

	fsName := "BinFS"
	if buildTag != "" {
		fsName = "_binfs" + buildTag
	}

	b.WriteString(fmt.Sprintf("var (\n%v = %#v\n)", fsName, fs))
	return b.String()
}

func generateFiles(pkgName string, fileSystems map[string]*binclude.FileSystem) error {
	for buildTag, fs := range fileSystems {
		if buildTag == "default" {
			err := generateFile(pkgName, fs)
			if err != nil {
				return err
			}
			continue
		}

		err := generateTagFile(pkgName, fs, buildTag)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateFile(pkgName string, fs *binclude.FileSystem) error {
	return writeCodeToFile("binclude.go", generateCode(pkgName, fs, ""))
}

func generateTagFile(pkgName string, fs *binclude.FileSystem, buildTag string) error {
	code := generateCode(pkgName, fs, buildTag)

	initFunc := `
func init() {
		BinFS.Lock()
		for path, file := range _binfs` + buildTag + `.Files {
			BinFS.Files[path] = file
		}
		BinFS.Unlock()
	}`

	code += initFunc
	return writeCodeToFile("binclude"+buildTag+".go", code)
}

func writeCodeToFile(filename string, code string) error {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	fmtCode, err := format.Source([]byte(code))
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filename, fmtCode, 0o666)
}
