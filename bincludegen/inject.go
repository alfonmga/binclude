package bincludegen

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/lu4p/binclude"
)

func generateCode(pkgName string, fs *binclude.FileSystem, buildTag string) *bytes.Buffer {
	b := bytes.NewBuffer(nil)

	header := `// Code generated by https://github.com/lu4p/binclude; DO NOT EDIT.

package ` + pkgName + "\n"

	b.WriteString(header)

	b.WriteString("import (\n")
	b.WriteString("\"github.com/lu4p/binclude\"\n")
	if len(fs.Files) > 0 {
		b.WriteString("\"time\"\n")
	}
	b.WriteString(")\n")

	fsName := "BinFS"
	if buildTag != "" {
		fsName = "_binfs" + buildTag
	}

	fs.Code(b, fsName)

	return b
}

func generateFiles(dir, pkgName string, fileSystems map[string]*binclude.FileSystem) error {
	for buildTag, fs := range fileSystems {
		if buildTag == "default" {
			err := generateFile(dir, pkgName, fs)
			if err != nil {
				return err
			}
			continue
		}

		err := generateTagFile(dir, pkgName, fs, buildTag)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateFile(dir, pkgName string, fs *binclude.FileSystem) error {
	path := filepath.Join(dir, "binclude.go")
	b := generateCode(pkgName, fs, "")
	return writeCodeToFile(path, b.Bytes())
}

func generateTagFile(dir, pkgName string, fs *binclude.FileSystem, buildTag string) error {
	b := generateCode(pkgName, fs, buildTag)

	initFunc := `
func init() {
	BinFS.Lock()
	for path, file := range _binfs` + buildTag + `.Files {
		BinFS.Files[path] = file
	}
	BinFS.Unlock()
}`

	b.WriteString(initFunc)
	path := filepath.Join(dir, "binclude"+buildTag+".go")
	return writeCodeToFile(path, b.Bytes())
}

func writeCodeToFile(filename string, code []byte) error {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	fmtCode, err := format.Source([]byte(code))
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filename, fmtCode, 0o666)
}
